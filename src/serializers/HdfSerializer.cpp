/********************************************************************************
 *                                                                              *
 * This file is part of IfcOpenShell.                                           *
 *                                                                              *
 * IfcOpenShell is free software: you can redistribute it and/or modify         *
 * it under the terms of the Lesser GNU General Public License as published by  *
 * the Free Software Foundation, either version 3.0 of the License, or          *
 * (at your option) any later version.                                          *
 *                                                                              *
 * IfcOpenShell is distributed in the hope that it will be useful,              *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of               *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the                 *
 * Lesser GNU General Public License for more details.                          *
 *                                                                              *
 * You should have received a copy of the Lesser GNU General Public License     *
 * along with this program. If not, see <http://www.gnu.org/licenses/>.         *
 *                                                                              *
 ********************************************************************************/


#include "HdfSerializer.h"



#include "../ifcgeom_schema_agnostic/IfcGeomRenderStyles.h"

#include "../ifcparse/utils.h"

#include <boost/lexical_cast.hpp>
#include <iomanip>


const H5std_string  FILE_NAME("output_file.h5");


HdfSerializer::HdfSerializer(const std::string& obj_filename, const std::string& mtl_filename, const SerializerSettings& settings)
	: GeometrySerializer(settings)
	, mtl_filename(mtl_filename)
	, obj_stream(IfcUtil::path::from_utf8(obj_filename).c_str())
	, mtl_stream(IfcUtil::path::from_utf8(mtl_filename).c_str())
	, vcount_total(1)
	, file(FILE_NAME, H5F_ACC_TRUNC)


{
	obj_stream << std::setprecision(settings.precision);
	mtl_stream << std::setprecision(settings.precision);
	guids = {};
}


bool HdfSerializer::ready() {
	return obj_stream.is_open() && mtl_stream.is_open();
}

void HdfSerializer::writeHeader() {
	obj_stream << "# File generated by IfcOpenShell " << IFCOPENSHELL_VERSION << "\n";
#ifdef WIN32
	const char dir_separator = '\\';
#else
	const char dir_separator = '/';
#endif
	std::string mtl_basename = mtl_filename;
	std::string::size_type slash = mtl_basename.find_last_of(dir_separator);
	if (slash != std::string::npos) {
		mtl_basename = mtl_basename.substr(slash + 1);
	}
	obj_stream << "mtllib " << mtl_basename << "\n";
	mtl_stream << "# File generated by IfcOpenShell " << IFCOPENSHELL_VERSION << "\n";
}

void HdfSerializer::writeMaterial(const IfcGeom::Material& style)
{
	std::string material_name = (settings().get(SerializerSettings::USE_MATERIAL_NAMES)
		? style.original_name() : style.name());
	IfcUtil::sanitate_material_name(material_name);
	mtl_stream << "newmtl " << material_name << "\n";

	if (style.hasDiffuse()) {
		const double* diffuse = style.diffuse();
		mtl_stream << "Kd " << diffuse[0] << " " << diffuse[1] << " " << diffuse[2] << "\n";
	}
	if (style.hasSpecular()) {
		const double* specular = style.specular();
		mtl_stream << "Ks " << specular[0] << " " << specular[1] << " " << specular[2] << "\n";
	}
	if (style.hasSpecularity()) {
		mtl_stream << "Ns " << style.specularity() << "\n";
	}
	if (style.hasTransparency()) {
		const double transparency = 1.0 - style.transparency();
		if (transparency < 1) {
			mtl_stream << "d " << transparency << "\n";
		}
	}
}



void HdfSerializer::write(const IfcGeom::TriangulationElement<real_t>* o){

	std::string guid = o->guid();
	//Logger::Status(guid);
	//Logger::Status(o->context());
	//Logger::Status("\n");

	H5::Group elementGroup;
	H5::Group meshGroup;
	H5::DataSet positionsDataset;
	H5::DataSet normalsDataset;
	H5::DataSet indicesDataset;


	const IfcGeom::Representation::Triangulation<real_t>& mesh = o->geometry();
	const int vcount = (int)mesh.verts().size() / 3;
	const int fcount = (int)mesh.faces().size() / 3;


	if (guid == "2OBrcmyk58NupXoVOHUvr4") {
		Logger::Status("Found");
	}

	if (std::find(guids.begin(), guids.end(), guid) != guids.end())
	{
		elementGroup = file.openGroup(guid);
		meshGroup = elementGroup.openGroup("Triangle Mesh");
		positionsDataset = meshGroup.openDataSet("Positions");


	} else {

		guids.insert(guid);
		elementGroup = file.createGroup(guid);
		meshGroup = elementGroup.createGroup("Triangle Mesh");

		H5std_string  DATASET_NAME_POSITIONS("Positions");
		H5std_string  DATASET_NAME_NORMALS("Normals");
		H5std_string  DATASET_NAME_INDICES("Indices");

		const int   RANK = 2;
		hsize_t     dimsf[2];             
		dimsf[0] = vcount;
		dimsf[1] = 3;
		H5::DataSpace dataspace(RANK, dimsf);

		hsize_t     dimsfaces[2];
		dimsfaces[0] = fcount;
		dimsfaces[1] = 3;
		H5::DataSpace face_dataspace(RANK, dimsfaces);

		H5::IntType Intdatatype(H5::PredType::NATIVE_INT);
		H5::FloatType datatype(H5::PredType::NATIVE_DOUBLE);
		datatype.setOrder(H5T_ORDER_LE);

		positionsDataset = meshGroup.createDataSet(DATASET_NAME_POSITIONS, datatype, dataspace);
		normalsDataset = meshGroup.createDataSet(DATASET_NAME_NORMALS, Intdatatype, dataspace);
		indicesDataset = meshGroup.createDataSet(DATASET_NAME_INDICES, Intdatatype, face_dataspace);


		for (std::vector<real_t>::const_iterator it = mesh.verts().begin(); it != mesh.verts().end(); ) {
			const real_t x = *(it++);
			const real_t y = *(it++);
			const real_t z = *(it++);
			double_data_container.push_back(x);
			double_data_container.push_back(y);
			double_data_container.push_back(z);

		}

		positionsDataset.write(double_data_container.data(), H5::PredType::NATIVE_DOUBLE);
		double_data_container.clear();


		for (std::vector<real_t>::const_iterator it = mesh.normals().begin(); it != mesh.normals().end(); ) {
			const real_t x = *(it++);
			const real_t y = *(it++);
			const real_t z = *(it++);
			int_data_container.push_back((int)x);
			int_data_container.push_back((int)y);
			int_data_container.push_back((int)z);

		}
		normalsDataset.write(int_data_container.data(), H5::PredType::NATIVE_INT);
		int_data_container.clear();



		for (std::vector<int>::const_iterator it = mesh.faces().begin(); it != mesh.faces().end(); ) {
			const real_t x = *(it++);
			const real_t y = *(it++);
			const real_t z = *(it++);
			int_data_container.push_back(x);
			int_data_container.push_back(y);
			int_data_container.push_back(z);

		}

		indicesDataset.write(int_data_container.data(), H5::PredType::NATIVE_INT);
		int_data_container.clear();

	}

}
